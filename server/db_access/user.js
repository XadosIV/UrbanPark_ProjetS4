const {dbConnection, dbName} = require('../database');
const Errors = require('../errors');

/**
 * GetUsers
 * Get all users matching parameters
 * 
 * @param {function(*,*)} callback (err, data)
 * @param {object} infos {first_name, last_name, email, password, id_spot}
 */
function GetUsers(callback, infos){
	sql = `SELECT id, first_name, last_name, email, id_spot, role FROM ${dbName}.User WHERE email LIKE :email AND role LIKE :role AND last_name LIKE :last_name AND first_name LIKE :first_name `;
	if (infos.id_spot) {
		sql += `AND id_spot = ` + infos.id_spot + `;`;
	}
	console.log("SQL at GetUsers : " + sql + " with " + JSON.stringify(infos));
	dbConnection.query(sql, {
		id:infos.id||'%',
		email:infos.email||'%',
		role:infos.role||'%',
		last_name:infos.last_name||'%',
		first_name:infos.first_name||'%'
	}, callback);
}

/**
 * DeleteUser
 * Delete user by id
 * 
 * @param {function(*,*)} callback (err, data)
 * @param {int} id
 */
function DeleteUser(callback, id){
	sql = `DELETE FROM ${dbName}.User WHERE id=:id;`;
	console.log("SQL at DeleteUser : " + sql + " with id=" + id);
	dbConnection.query(sql, {
		id:id
	}, callback);
}

/**
 * UpdateUser
 * Update user's information matching parameters
 * 
 * @param {function(*,*)} callback (err, data)
 * @param {object} infos {id, first_name, last_name, email, password, role, id_spot, id_spot_temp}
 */
function UpdateUser(callback, infos){

	//Verification syntaxe
	if (infos.email){
		if (!IsValidEmail(infos.email)){
			let errorCode = Errors.E_EMAIL_FORMAT_INVALID;
			let error = new Error(errorCode);
			error.code = errorCode;
			callback(error,{});
			return;
		}
	}
	// Verification syntaxe
	if (infos.password){
		if (!IsValidPassword(infos.password)){
			let errorCode = Errors.E_PASSWORD_FORMAT_INVALID;
			let error = new Error(errorCode);
			error.code = errorCode;
			callback(error,{});
			return;
		}
	}

	let checkNewTokenNeeded = () => {
		// Fonction envoyant la reqûete sql
		let sqlRequest = (err, token) => {
			if (err) callback(err, {});
		
			// if token generated, add it to infos
			if (token) infos.token = token;
		
			// concat parameters with commas for update syntax
			parameters = ""
			for (let key of Object.keys(infos)){
				if (key != "id"){
					if (["id_spot", "id_spot_temp"].includes(key.toLowerCase())){
						parameters += `\`${key}\`=${infos[key]},` // int value
					}else{
						parameters += `\`${key}\`='${infos[key]}',` // string value
					}
				}
			}
		
			//remove last comma
			parameters = parameters.slice(0,-1) // = remove last char
		
			sql = `UPDATE ${dbName}.User SET ${parameters} WHERE id=:id`;
		
			// placeholders variables gave as the request
			placeholders = {id:infos.id, parameters:parameters}
		
			console.log("SQL at UpdateUser : " + sql + " with " + JSON.stringify(placeholders));
			dbConnection.query(sql, placeholders, callback);
		}

		if 	(infos.email || infos.password){ // if a new token is needed
			const {GenerateNewToken} = require('./auth');
			GenerateNewToken(sqlRequest)
		}else{
			sqlRequest({}, null)
		}
	}

	//Verification doublon
	if (infos.email){
		GetUsers( (err, data) => {
			if (err) { // Not generated by us
				callback(err,data);
			}else if (data.length != 0){ // Email already used
				let errorCode = Errors.E_EMAIL_ALREADY_USED;
				let error = new Error(errorCode);
				error.code = errorCode;
				callback(error,data);
			}else{
				checkNewTokenNeeded()
			}
		}, {email:infos.email})
	}else{
		checkNewTokenNeeded()
	}
}

/**
 * GetUserFromToken
 * Get all users matching parameters
 * 
 * @param {function(*,*)} callback (err, data)
 * @param {object} infos {token}
 */
function GetUserFromToken(callback, infos){
	sql = `SELECT id, first_name, last_name, email, role, id_spot, id_spot_temp FROM ${dbName}.User WHERE  token=:token;`;
	console.log("SQL at GetUserFromToken : " + sql + " with " + JSON.stringify(infos));
	dbConnection.query(sql, {
		token: infos.token
	}, callback);
}

/**
 * IsValidEmail
 * Check if the string is a valid email
 * 
 * @param {string} email 
 * 
 * @return {boolean}
 */
function IsValidEmail(email){
	return email.toLowerCase().match(/^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|.(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/);
}

/**
 * IsValidPassword
 * Check if the string is a valid password
 * Minimum 8 characters long, a lower case, an upper case, a digitanda special character
 * 
 * @param {string} password 
 * 
 * @returns {boolean}
 */
function IsValidPassword(password){
	return password.match(/^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#\$%\^&\*])(?=.{8,})/);
}

/**
 * PostUser
 * Create a new user with "Abonné" role
 * 
 * @param {function(*,*)} callback (err, data)
 * @param {object} infos {first_name, last_name, email, password}
 */
function PostUser(callback, infos){
	const {GenerateNewToken} = require('./auth');

	if (!IsValidEmail(infos.email)){
		let errorCode = Errors.E_EMAIL_FORMAT_INVALID;
		let error = new Error(errorCode);
		error.code = errorCode;
		callback(error,[]);
	}else if (!IsValidPassword(infos.password)){
		let errorCode = Errors.E_PASSWORD_FORMAT_INVALID;
		let error = new Error(errorCode);
		error.code = errorCode;
		callback(error,[]);
	}else{
		GetUsers((err, data) => {
			if (err) { // Not generated by us
				callback(err,data);
			}else if (data.length != 0){ // Email already used
				let errorCode = Errors.E_EMAIL_ALREADY_USED;
				let error = new Error(errorCode);
				error.code = errorCode;
				callback(error,data);
			}else{
				GenerateNewToken((err, token) => {
					if (err){ // Not generated by us
						callback(err,data);
					}else{
						let sql=`INSERT INTO ${dbName}.User (first_name, last_name, email, password, role, token) VALUES (:first_name,:last_name,:email,:password,:role,:token);`;
						infos.role="Abonné";
						infos.token = token;
						console.log("SQL at PostUser : " + sql + " with " + JSON.stringify(infos));
						dbConnection.query(sql, infos, callback);
					}
				});
			}
		}, {email:infos.email});
	}
}

module.exports = {GetUsers, PostUser, GetUserFromToken, DeleteUser, UpdateUser};